package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	postgres "newPractice/graph/Connection"
	"newPractice/graph/model"
	"strconv"

	"github.com/360EntSecGroup-Skylar/excelize"
)

// CreateStudent is the resolver for the createStudent field.
func (r *mutationResolver) CreateStudent(ctx context.Context, input *model.NewStudent) (*model.StudentInfo, error) {
	// panic(fmt.Errorf("not implemented: CreateStudent - createStudent"))
	conn := postgres.Conn()
	var res model.StudentInfo
	//log.Println("kmmmmmmmm88888888888888mmmmmmmmmmmm") // debugging
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `
	INSERT INTO public.students (roll_no, name, dept, year, mob_no, email, dob)
	VALUES ($1, $2, $3, $4, $5, $6, $7)
	RETURNING roll_no
`
	// use returning clause
	// log.Println("kmmmmmmmmmmmmmmmmmmmm", input.RollNo, input.Name, input.Dept, input.Year, input.MobNo, input.Email, input.Dob)
	_, err := db.Exec(sqlstatement, input.RollNo, input.Name, input.Dept, input.Year, input.MobNo, input.Email, input.Dob)
	log.Println(err, ",,,,,,,,,,,,,,,,")
	if err != nil {
		res.Error = true
		res.Message = err.Error()
		return &res, nil
	}
	res.Error = false
	res.Message = "data inserted successfully"

	fmt.Println("data inserted successfully")

	return &res, nil
}

// UpdateStudent is the resolver for the updateStudent field.
func (r *mutationResolver) UpdateStudent(ctx context.Context, input model.UpdateStudent) (*model.StudentInfo, error) {
	// panic(fmt.Errorf("not implemented: UpdateStudent - updateStudent"))
	var res *model.StudentInfo
	conn := postgres.Conn()
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := ` UPDATE database SET name =$1 ,dept= $2,year=$3,mob_no=$4,email=$5, dob=$6 WHERE roll_no=$7 `
	log.Println(sqlstatement)
	_, err := db.Exec(sqlstatement, input.Name, input.Dept, input.Year, input.MobNo, input.Email, input.Dob, input.RollNo)
	
	if err != nil {
		fmt.Println("sql_err", err)
		res.Error = true
		res.Message = err.Error()
		return res, err
	}
	respUser := model.StudentInfo{
		Error:   false,
		Message: "data updated successfully",
	}

	fmt.Println("data updated successfully")

	return &respUser, nil
}

// RemoveStudent is the resolver for the removeStudent field.
func (r *mutationResolver) RemoveStudent(ctx context.Context, input model.DeleteStudent) (string, error) {
	// panic(fmt.Errorf("not implemented: RemoveStudent - removeStudent"))
	conn := postgres.Conn()
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `DELETE FROM dataBase WHERE roll_no = $1`
	_, err := db.Exec(sqlstatement, input.RollNo)
	if err != nil {
		fmt.Println("sql_err", err)
		return "", err
	}

	return "data deleted successfully", nil
}

// FetchStudent is the resolver for the FetchStudent field.
func (r *mutationResolver) FetchStudent(ctx context.Context) ([]*model.StudentInfo, error) {
	// panic(fmt.Errorf("not implemented: FetchStudent - FetchStudent"))
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := ` select roll_no,name,dept,year,mob_no,email,dob from dataBase `
	var user1 []*model.StudentInfo
	data, err := db.Query(sqlStatement)
	// log.Println("data:", &data)
	// log.Println("datas:", data)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}
	for data.Next() {
		var user model.StudentInfo
		err = data.Scan(&user.RollNo, &user.Name, &user.Dept, &user.Year, &user.MobNo, &user.Email, &user.Dob)
		if err != nil {
			fmt.Println("sql_err:", err)
			return nil, err
		}
		user1 = append(user1, &user)
	}
	f := excelize.NewFile()
	f.SetCellValue("Sheet1", "A1", "RollNo")
	f.SetCellValue("Sheet1", "B1", "Name")
	f.SetCellValue("Sheet1", "C1", "Depertment")
	f.SetCellValue("Sheet1", "D1", "Year")
	f.SetCellValue("Sheet1", "E1", "Mobile_No")
	f.SetCellValue("Sheet1", "F1", "Email")
	f.SetCellValue("Sheet1", "G1", "Dob")

	for i, value := range user1 {
		id := *&value.RollNo
		name := *&value.Name
		Depertment := *&value.Dept
		Year := *&value.Year
		Mob_No := *&value.MobNo
		Email := *&value.Email
		Dob := *&value.Dob
		a := strconv.Itoa(i + 2)
		f.SetCellValue("Sheet1", ("A" + a), id)
		f.SetCellValue("Sheet1", ("B" + a), name)
		f.SetCellValue("Sheet1", ("C" + a), Depertment)
		f.SetCellValue("Sheet1", ("D" + a), Year)
		f.SetCellValue("Sheet1", ("E" + a), Mob_No)
		f.SetCellValue("Sheet1", ("F" + a), Email)
		f.SetCellValue("Sheet1", ("G" + a), Dob)

	}

	err = f.SaveAs("MyData.xlsx")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("Excel File created and data inserted")
	}
	return user1, nil
}

// AddAddress is the resolver for the AddAddress field.
func (r *mutationResolver) AddAddress(ctx context.Context, input *model.AddAddress) (*model.Address, error) {
	// panic(fmt.Errorf("not implemented: AddAddress - AddAddress"))
	conn := postgres.Conn()
	var res model.Address
	log.Println("kmmmmmmmm88888888888888mmmmmmmmmmmm")
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `INSERT INTO address
	(roll_no,city,district,pin,state)
	VALUES($1, $2, $3, $4, $5
	)RETURNING roll_no`
	// use returning clause
	// log.Println("kmmmmmmmmmmmmmmmmmmmm", input.RollNo, input.Name, input.Dept, input.Year, input.MobNo, input.Email, input.Dob)
	_, err := db.Exec(sqlstatement, input.RollNo, input.City, input.District, input.Pin, input.State)
	log.Println(err, ",,,,,,,,,,,,,,,,")
	if err != nil {
		res.Error = true
		res.Message = err.Error()
		return &res, nil
	}
	res.Error = false
	res.Message = "Address data inserted successfully"

	fmt.Println("Address data inserted successfully")

	return &res, nil
}

// FetchAddress is the resolver for the FetchAddress field.
func (r *mutationResolver) FetchAddress(ctx context.Context) ([]*model.Address, error) {
	// panic(fmt.Errorf("not implemented: FetchAddress - FetchAddress"))
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := ` select roll_no,city,district,pin,state from address `
	var user1 []*model.Address
	data, err := db.Query(sqlStatement)
	// log.Println("data:", &data)
	// log.Println("datas:", data)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}
	for data.Next() {
		var user model.Address
		err = data.Scan(&user.RollNo, &user.City, &user.District, &user.Pin, &user.State)
		if err != nil {
			fmt.Println("sql_err:", err)
			return nil, err
		}
		user1 = append(user1, &user)
	}
	f := excelize.NewFile()
	f.SetCellValue("Sheet1", "A1", "RollNo")
	f.SetCellValue("Sheet1", "B1", "City")
	f.SetCellValue("Sheet1", "C1", "District")
	f.SetCellValue("Sheet1", "D1", "Pin")
	f.SetCellValue("Sheet1", "E1", "State")

	for i, value := range user1 {
		id := *&value.RollNo
		city := *&value.City
		district := *&value.District
		pin := *&value.Pin
		state := *&value.State

		a := strconv.Itoa(i + 2)
		f.SetCellValue("Sheet1", ("A" + a), id)
		f.SetCellValue("Sheet1", ("B" + a), city)
		f.SetCellValue("Sheet1", ("C" + a), district)
		f.SetCellValue("Sheet1", ("D" + a), pin)
		f.SetCellValue("Sheet1", ("E" + a), state)

	}

	err = f.SaveAs("Address.xlsx")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(" Address Excel File created and data inserted")
	}
	return user1, nil
}

// AddMarks is the resolver for the AddMarks field.
func (r *mutationResolver) AddMarks(ctx context.Context, input *model.AddMarks) (*model.Marks, error) {
	// panic(fmt.Errorf("not implemented: AddMarks - AddMarks"))
	conn := postgres.Conn()
	var res model.Marks
	log.Println("kmmmmmmmm88888888888888mmmmmmmmmmmm")
	db, _ := sql.Open("postgres", conn)
	defer db.Close()
	sqlstatement := `INSERT INTO marks
	(roll_no,physics,chemistry,mathematics)
	VALUES($1, $2, $3, $4
	)`
	// use returning clause
	// log.Println("kmmmmmmmmmmmmmmmmmmmm", input.RollNo, input.Name, input.Dept, input.Year, input.MobNo, input.Email, input.Dob)
	_, err := db.Exec(sqlstatement, input.RollNo, input.Physics, input.Chemistry, input.Mathematics)
	log.Println(err, ",,,,,,,,,,,,,,,,")
	if err != nil {
		res.Error = true
		res.Message = err.Error()
		return &res, nil
	}
	res.Error = false
	res.Message = "Marks data inserted successfully"

	fmt.Println("Marks data inserted successfully")

	return &res, nil
}

// FetchMarks is the resolver for the FetchMarks field.
func (r *mutationResolver) FetchMarks(ctx context.Context) ([]*model.Marks, error) {
	// panic(fmt.Errorf("not implemented: FetchMarks - FetchMarks"))
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := ` select roll_no,physics,chemistry,mathematics from marks `
	var user1 []*model.Marks
	data, err := db.Query(sqlStatement)
	// log.Println("data:", &data)
	// log.Println("datas:", data)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}
	for data.Next() {
		var user model.Marks
		err = data.Scan(&user.RollNo, &user.Physics, &user.Chemistry, &user.Mathematics)
		if err != nil {
			fmt.Println("sql_err:", err)
			return nil, err
		}
		user1 = append(user1, &user)
	}
	f := excelize.NewFile()
	f.SetCellValue("Sheet1", "A1", "RollNo")
	f.SetCellValue("Sheet1", "B1", "Physics")
	f.SetCellValue("Sheet1", "C1", "Chemistry")
	f.SetCellValue("Sheet1", "D1", "Mathematics")

	for i, value := range user1 {
		id := *&value.RollNo
		phy := *&value.Physics
		chem := *&value.Chemistry
		math := *&value.Mathematics

		a := strconv.Itoa(i + 2)
		f.SetCellValue("Sheet1", ("A" + a), id)
		f.SetCellValue("Sheet1", ("B" + a), phy)
		f.SetCellValue("Sheet1", ("C" + a), chem)
		f.SetCellValue("Sheet1", ("D" + a), math)

	}

	err = f.SaveAs("Marks.xlsx")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(" Marks Excel File created and data inserted")
	}
	return user1, nil
}

// JoinStudent is the resolver for the JoinStudent field.
func (r *mutationResolver) JoinStudent(ctx context.Context) ([]*model.Join, error) {
	// panic(fmt.Errorf("not implemented: JoinStudent - JoinStudent"))
	conn := postgres.Conn()
	db, err := sql.Open("postgres", conn)
	if err != nil {
		return nil, err
	}
	defer db.Close()

	sqlStatement := ` select s.roll_no,s.name,s.dept,s.email,a.city,a.district,a.pin,a.state,m.physics,m.chemistry,m.mathematics from database as s JOIN address as a ON s.roll_no=a.roll_no JOIN
    marks AS m ON s.roll_no = m.roll_no `
	var user1 []*model.Join
	data, err := db.Query(sqlStatement)
	// log.Println("data:", &data)
	// log.Println("datas:", data)
	if err != nil {
		fmt.Println("sql_err:", err)
		return nil, err
	}
	for data.Next() {
		var user model.Join
		err = data.Scan(&user.RollNo, &user.Name, &user.Dept, &user.Email, &user.City, &user.District, &user.Pin, &user.State, &user.Physics, &user.Chemistry, &user.Mathematics)
		if err != nil {
			fmt.Println("sql_err:", err)
			return nil, err
		}
		user1 = append(user1, &user)
	}
	f := excelize.NewFile()
	f.SetCellValue("Sheet1", "A1", "RollNo")
	f.SetCellValue("Sheet1", "B1", "Name")
	f.SetCellValue("Sheet1", "C1", "Depertment")
	f.SetCellValue("Sheet1", "D1", "Email")
	f.SetCellValue("Sheet1", "E1", "City")
	f.SetCellValue("Sheet1", "F1", "District")
	f.SetCellValue("Sheet1", "G1", "Pin")
	f.SetCellValue("Sheet1", "H1", "State")
	f.SetCellValue("Sheet1", "I1", "Physics")
	f.SetCellValue("Sheet1", "J1", "Chemistry")
	f.SetCellValue("Sheet1", "K1", "Mathematics")

	for i, value := range user1 {
		id := *&value.RollNo
		name := *&value.Name
		dept := *&value.Dept
		email := *&value.Email
		city := *&value.City
		district := *&value.District
		pin := *&value.Pin
		state := *&value.State
		phy := *&value.Physics
		chem := *&value.Chemistry
		math := *&value.Mathematics

		a := strconv.Itoa(i + 2)
		f.SetCellValue("Sheet1", ("A" + a), id)
		f.SetCellValue("Sheet1", ("B" + a), name)
		f.SetCellValue("Sheet1", ("C" + a), dept)
		f.SetCellValue("Sheet1", ("D" + a), email)
		f.SetCellValue("Sheet1", ("E" + a), city)
		f.SetCellValue("Sheet1", ("F" + a), district)
		f.SetCellValue("Sheet1", ("G" + a), pin)
		f.SetCellValue("Sheet1", ("H" + a), state)
		f.SetCellValue("Sheet1", ("I" + a), phy)
		f.SetCellValue("Sheet1", ("J" + a), chem)
		f.SetCellValue("Sheet1", ("K" + a), math)

	}

	err = f.SaveAs("JoinData.xlsx")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(" Address Excel File created and data inserted")
	}
	return user1, nil
}

// Students is the resolver for the students field.
func (r *queryResolver) Students(ctx context.Context) ([]*model.StudentInfo, error) {
	panic(fmt.Errorf("not implemented: Students - students"))
}

// Student is the resolver for the student field.
func (r *queryResolver) Student(ctx context.Context, rollNo int) (*model.StudentInfo, error) {
	panic(fmt.Errorf("not implemented: Student - student"))
}

// Username is the resolver for the username field.
func (r *queryResolver) Username(ctx context.Context, name *string) ([]*model.StudentInfo, error) {
	panic(fmt.Errorf("not implemented: Username - username"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
